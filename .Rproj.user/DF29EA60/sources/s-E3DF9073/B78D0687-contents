
coded_vars <- colnames(df)
ch_d <- read_csv('eHRAF-data/CH-coded-dataset.csv')
tmp <- sciExpertiseHRAF::coded_data
tmp2 <- sciExpertiseHRAF::coded_categorical %>% 
  dplyr::select(
    textid,
    male,
    female,
    case,
    model
  )
tmp <- tmp %>% left_join(tmp2, by='textid')
al_d <- tmp %>% arrange(textid)

# checking for matched cols and rows
# table(colnames(al_d)==colnames(ch_d))
# table(al_d$textid==ch_d$textid)

colnames(al_d)[which(colnames(al_d)=='samesex_deference')] <- 'deference'
colnames(ch_d)[which(colnames(ch_d)=='samesex_deference')] <- 'deference' 
al_d$social_learning <- as.numeric(
  al_d$is_mentor | al_d$apprenticeship | al_d$shares_knowhow_experts | al_d$shares_knowhow_nonexperts
)
al_d$apprenticeship <- NULL; al_d$is_mentor <- NULL; al_d$shares_knowhow_experts <- NULL; al_d$shares_knowhow_nonexperts <- NULL

al_d$seek_proximity[al_d$preferred_socialpartner==1] <- 1
al_d$preferred_socialpartner <- NULL

al_d <- cbind(
  data.frame(textid=al_d$textid,
             male=al_d$male, female=al_d$female,
             stringsAsFactors=FALSE),
  al_d[colnames(al_d) %in% coded_vars]
)


ch_d$social_learning <- as.numeric(
  ch_d$is_mentor | ch_d$apprenticeship | ch_d$shares_knowhow_experts | ch_d$shares_knowhow_nonexperts
)
ch_d$apprenticeship <- NULL; ch_d$is_mentor <- NULL; ch_d$shares_knowhow_experts <- NULL; ch_d$shares_knowhow_nonexperts <- NULL
ch_d$seek_proximity[ch_d$preferred_socialpartner==1] <- 1
ch_d$preferred_socialpartner <- NULL
ch_d <- cbind(
  data.frame(textid=ch_d$textid,
             male=ch_d$male, female=ch_d$female,
             stringsAsFactors=FALSE),
  ch_d[colnames(ch_d) %in% coded_vars]
)

al_d$coder <- 'aaron'
ch_d$coder <- 'cynthia'

ps <- data.table::rbindlist(list(al_d, ch_d))

a = c()
k = c()
v = c()
for (i in 2:(ncol(ps)-1)){
  nm = names(ps)[i]
  e.wide = dcast(ps, textid ~ coder, value.var=names(ps)[i])
  agr = agree(e.wide[,2:3])
  kpa = kappa2(e.wide[,2:3])
  a = c(a, agr$value)
  k = c(k, kpa$value)
  v = c(v, nm)
}

ps.irr=data.frame(variable=v, agreement=round(a, 2), kappa=round(k, 2))

# treat all ratings as a single, 1 dimensional vector
al <- al_d[sapply(al_d, is.numeric)]
ch <- ch_d[sapply(ch_d, is.numeric)]
# irr2 <- irr_d[sapply(irr_d, is.numeric)]

ch2 <- as.vector(as.matrix(ch))
al2 <- as.vector(as.matrix(al))
# irr2 <- as.vector(as.matrix(irr2))
# sum(ch2==al2)/length(ch2)

# Chance-corrected agreement for PS
ratings = data.frame(al=al2, ch=ch2)

# Gwet
ac1 = gwet.ac1.table(table(ratings$al, ratings$ch))
#ac1 = round(ac1, 2)

# Kappa
kap_irr = kappa2(ratings)

# Bangdiwala's B
#bangdiwala = agreementplot(table(ratings$ch, ratings$al))

# Correlation and Kappa
#ps.total.cor = cor(al2, ch2, method='k')
ps.total.agree = agree(cbind(al2, ch2))
ps.total.kappa = kappa2(cbind(al2, ch2))

kappa = ps.total.kappa$value
props = prop.table(table(c(al2, ch2)))
K = 3 # number of categories

w = props[[1]]^2 + props[[2]]^2 + props[[3]]^2
s = kappa*(1-(w*K)) - K*(1-w)
a =  (s - sqrt(s*s - s*K*(kappa*(K-1)*(K-2) + (1-w)*(kappa-1))))/(s*K)
rater.accuracy = round(100*a, 1)